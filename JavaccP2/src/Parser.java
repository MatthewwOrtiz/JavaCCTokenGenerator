/* Generated By:JavaCC: Do not edit this line. Parser.java */
import java.io.BufferedWriter;
import java.io.FileNotFoundException;
import java.io.PrintWriter;
import java.io.UnsupportedEncodingException;
import java.util.ArrayList;
public class Parser implements ParserConstants {
        //initialze needed arrays
        static char[] first = {'A','B','C','D','E','F','G','H','I','J','K','L','M','N','O','P','Q','R','S','T','U','V','W','X','Y','Z',
                                        'a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z' };
        static int[] position = new int[52];
        static char[] symbol = new char[10000];
        static int[] next = new int[10000];
        static int zz = 0;
        static BufferedWriter writer;

//fill the arrays with the needed information
static void fillPost()
{
        for(int i = 0; i<position.length;i++)
                {
                        position[i]=-1;
                }
        for (int i = 0;i<symbol.length;i++)
        {
                symbol[i]=' ';
        }

}
//insert function
static void insert(String key) {

        char letter = key.charAt(0); // get the first letter (check)
        int place = 0;
        for (int j=0; j<52;j++)         //find the spot the letter is in the trie
        {
                if (letter == first[j]) // find the Letter in the array
                {
                        place = j;                      //saves the letter spot
                }
        }


        if (position[place]!=-1) //if spot is taken
        {
                int newSpot = position[place];                  //find next spot
                while(symbol[newSpot]!=' ')
                {
                        newSpot++;
                }
                int nnext = newSpot;
                for (int i=1;i<key.length();i++)        //once spot is found insert element
                {
                        symbol[newSpot]=key.charAt(i);
                        newSpot++;
                }
                symbol[newSpot]='@';                                    //place termial symbol
                zz=newSpot+1;
                next[nnext] = newSpot;
        }

        if (position[place]==-1) //if spot is empty
        {
          position[place] = zz;
          int nnext = zz;
                for (int i = 1;i<key.length();i++ ) //place key at next open spot
                {
                        symbol[zz] = key.charAt(i);
                        zz=zz+1;
                }
                        symbol[zz]='@';
                        zz=zz+1;
                        next[nnext] = zz;
        }
  }

static boolean search(String key)
{
        char letter = key.charAt(0); // get the first letter (check)
        int place = 0;
        for (int j=0; j<52;j++)         //find the spot the letter is in the trie
        {
                if (letter == first[j]) // find the Letter in the array
                {
                        place = j;
                }
        }

        int find = position[place];                                     // finds if element is filled
        if (find==-1){return false;}                            //if empty false
        for(int i = 1;i<key.length();i++)                       //if not emtpy continue 
        {
          if(find>symbol.length-1){break;}                      // look through array for key
                if(symbol[find]!=key.charAt(i)) {i=1;}
                find=find+1;
        }
        if(find >9999) {find=9999;}
        if(symbol[find]=='@') {return true;}            //if found return true
        else return false;

}
// print method for trie
static void printTrie()
        {
                for (int i =0; i<26;i++)
                {
                        System.out.print("   " + first[i]);
                }

System.out.println();

                for (int i =0; i<26;i++)
                {
                        System.out.print(String.format("%4d",position[i]));
                }
System.out.println();
                for (int i =26; i<52;i++)
                {
                        System.out.print("   " + first[i]);
                }

System.out.println();

                for (int i =26; i<52;i++)
                {
                        System.out.print(String.format("%4d",position[i]));
                }



System.out.println();
System.out.println();
                for (int i = 0; i<zz;i++)
                {
                        System.out.print(String.format("%4d",i));

                }
System.out.println();
                for (int i = 0; i<zz;i++)
                {
                        System.out.print("   " + symbol[i]);
                }
System.out.println();
                for (int i = 0; i<zz;i++)
                {
                        System.out.print(String.format("%4d",next[i]));
                }

    }


       public static void main(String[] args) throws ParseException, TokenMgrError, FileNotFoundException, UnsupportedEncodingException {
                writer = new BufferedWriter(new FileWriter(fileName));

        Parser parser = new Parser(System.in);
                fillPost();
                ArrayList<String> list = new ArrayList<String>();
        parser.start();
        writer.close();
    }

//grammar
  final public void start() throws ParseException {
                Token t;
    label_1:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case DBLCONST:
      case INTCONST:
      case ADDOP:
      case MULOP:
      case SUBOP:
      case SEMICOL:
      case COMMA:
      case BOOLN:
      case ELS:
      case IMPL:
      case NEWAR:
      case RTRN:
      case MOD:
      case GRTEQ:
      case LESSEQ:
      case GRT:
      case AND:
      case RTBRC:
      case RTPRN:
      case BOOLCONST:
      case _INT:
      case DOT:
      case LFTBRACKET:
      case OR:
      case BRK:
      case EXTNDS:
      case NUL:
      case STRNG:
      case STRINGCONST:
      case LESS:
      case NEQ:
      case EQL:
      case ASSIGN:
      case LFTPRN:
      case LFTBRACE:
      case RTBRACE:
      case _IF:
      case NW:
      case READLN:
      case _WHLE:
      case DIV:
      case NOT:
      case DBL:
      case CLS:
      case FR:
      case INTRFC:
      case PRNTLN:
      case _VOID:
      case kill:
      case ID:
        ;
        break;
      default:
        jj_la1[0] = jj_gen;
        break label_1;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case DBLCONST:
        jj_consume_token(DBLCONST);
                if(search("doubleconst")!=true) {insert("doubleconst");}
            writer.println("doubleconst ");
        break;
      case INTCONST:
        jj_consume_token(INTCONST);
                if(search("intconst")!=true) {insert("intconst");}
            writer.print("intconst ");
        break;
      case ADDOP:
        jj_consume_token(ADDOP);
                if(search("add")!=true) {insert("add");}
            writer.print("add ");
        break;
      case MULOP:
        jj_consume_token(MULOP);
                if(search("multiplication")!=true) {insert("multiplication");}
            writer.print("multiplication ");
        break;
      case SUBOP:
        jj_consume_token(SUBOP);
                if(search("minus")!=true) {insert("minus");}
            writer.print("minus ");
        break;
      case SEMICOL:
        jj_consume_token(SEMICOL);
                if(search("semicol")!=true) {insert("semicol");}
            writer.print("semicol ");
        break;
      case COMMA:
        jj_consume_token(COMMA);
                if(search("comma")!=true) {insert("comma");}
            writer.print("comma ");
        break;
      case BOOLN:
        jj_consume_token(BOOLN);
                if(search("boolean")!=true) {insert("boolean");}
            writer.print("boolean ");
        break;
      case ELS:
        jj_consume_token(ELS);
                if(search("else")!=true) {insert("else");}
            writer.print("else ");
        break;
      case IMPL:
        jj_consume_token(IMPL);
                if(search("implements")!=true) {insert("implements");}
            writer.print("implements ");
        break;
      case NEWAR:
        jj_consume_token(NEWAR);
                if(search("newarray")!=true) {insert("newarray");}
            writer.print("newarray ");
        break;
      case RTRN:
        jj_consume_token(RTRN);
                if(search("return")!=true) {insert("return");}
            writer.print("return ");
        break;
      case MOD:
        jj_consume_token(MOD);
                if(search("mod")!=true) {insert("mod");}
            writer.print("mod ");
        break;
      case GRTEQ:
        jj_consume_token(GRTEQ);
                if(search("greaterequal")!=true) {insert("greaterequal");}
            writer.print("greaterequal ");
        break;
      case LESSEQ:
        jj_consume_token(LESSEQ);
                if(search("lessequal")!=true) {insert("lessequal");}
            writer.print("lessequal ");
        break;
      case GRT:
        jj_consume_token(GRT);
                if(search("greaterthan")!=true) {insert("greaterthan");}
            writer.print("greaterthan ");
        break;
      case AND:
        jj_consume_token(AND);
                if(search("and")!=true) {insert("and");}
            writer.print("and ");
        break;
      case RTBRC:
        jj_consume_token(RTBRC);
                if(search("rightbracket")!=true) {insert("rightbracket");}
            writer.print("rightbracket ");
        break;
      case RTPRN:
        jj_consume_token(RTPRN);
                if(search("rightparen")!=true) {insert("rightparen");}
            writer.print("rightparen ");
        break;
      case BOOLCONST:
        jj_consume_token(BOOLCONST);
                if(search("booleanconst")!=true) {insert("booleanconst");}
            writer.print("booleanconst ");
        break;
      case _INT:
        jj_consume_token(_INT);
                if(search("int")!=true) {insert("int");}
            writer.print("int ");
        break;
      case DOT:
        jj_consume_token(DOT);
                if(search("period")!=true) {insert("period");}
            writer.print("period ");
        break;
      case LFTBRACKET:
        jj_consume_token(LFTBRACKET);
                if(search("leftbracket")!=true) {insert("leftbracket");}
            writer.print("leftbracket ");
        break;
      case OR:
        jj_consume_token(OR);
                if(search("or")!=true) {insert("or");insert("or");}
            writer.print("or ");
        break;
      case BRK:
        jj_consume_token(BRK);
                if(search("break")!=true) {insert("break");}
            writer.print("break ");
        break;
      case EXTNDS:
        jj_consume_token(EXTNDS);
                if(search("extends")!=true) {insert("extends");}
            writer.print("extends ");
        break;
      case NUL:
        jj_consume_token(NUL);
                if(search("null")!=true) {insert("null");}
            writer.print("null ");
        break;
      case STRNG:
        jj_consume_token(STRNG);
                if(search("string")!=true) {insert("string");}
            writer.print("string ");
        break;
      case STRINGCONST:
        jj_consume_token(STRINGCONST);
                if(search("stringconst")!=true) {insert("stringconst");}
            writer.print("stringconst ");
        break;
      case LESS:
        jj_consume_token(LESS);
                if(search("less")!=true) {insert("less");}
            writer.print("less ");
        break;
      case NEQ:
        jj_consume_token(NEQ);
                if(search("notequal")!=true) {insert("notequal");}
            writer.print("notequal ");
        break;
      case EQL:
        jj_consume_token(EQL);
                if(search("equal")!=true) {insert("equal");}
            writer.print("equal ");
        break;
      case ASSIGN:
        jj_consume_token(ASSIGN);
                if(search("assign")!=true) {insert("assign");}
            writer.print("assign ");
        break;
      case LFTPRN:
        jj_consume_token(LFTPRN);
                if(search("leftparn")!=true) {insert("leftparn");}
            writer.print("leftparen ");
        break;
      case LFTBRACE:
        jj_consume_token(LFTBRACE);
                if(search("leftbrace")!=true) {insert("leftbrace");}
            writer.print("leftbrace ");
        break;
      case RTBRACE:
        jj_consume_token(RTBRACE);
                if(search("rightbrace")!=true) {insert("rightbrace");}
            writer.print("rightbrace ");
        break;
      case _IF:
        jj_consume_token(_IF);
                if(search("if")!=true) {insert("if");}
            writer.print("if ");
        break;
      case NW:
        jj_consume_token(NW);
                if(search("new")!=true) {insert("new");}
            writer.print("new ");
        break;
      case READLN:
        jj_consume_token(READLN);
                if(search("readline")!=true) {insert("readline");}
            writer.print("readline ");
        break;
      case _WHLE:
        jj_consume_token(_WHLE);
                if(search("while")!=true) {insert("while");}
            writer.print("while ");
        break;
      case DIV:
        jj_consume_token(DIV);
                if(search("divide")!=true) {insert("divide");}
            writer.print("divide ");
        break;
      case NOT:
        jj_consume_token(NOT);
                if(search("not")!=true) {insert("not");}
            writer.print("not ");
        break;
      case DBL:
        jj_consume_token(DBL);
                if(search("double")!=true) {insert("double");}
            writer.print("double ");
        break;
      case CLS:
        jj_consume_token(CLS);
                if(search("class")!=true) {insert("class");}
            writer.print("class ");
        break;
      case FR:
        jj_consume_token(FR);
                if(search("for")!=true) {insert("for");}
            writer.print("for ");
        break;
      case INTRFC:
        jj_consume_token(INTRFC);
                if(search("interface")!=true) {insert("interface");}
            writer.print("inteface ");
        break;
      case PRNTLN:
        jj_consume_token(PRNTLN);
                if(search("println")!=true) {insert("println");}
            writer.print("println ");
        break;
      case _VOID:
        jj_consume_token(_VOID);
                if(search("void")!=true) {insert("void");}
            writer.print("void ");
        break;
      case kill:
        jj_consume_token(kill);
            printTrie();
        break;
      case ID:
        t = jj_consume_token(ID);
                if(search(t.toString())!=true) {insert(t.toString());}
            writer.print("id ");
        break;
      default:
        jj_la1[1] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
    jj_consume_token(0);
                writer.println();
  }

  /** Generated Token Manager. */
  public ParserTokenManager token_source;
  SimpleCharStream jj_input_stream;
  /** Current token. */
  public Token token;
  /** Next token. */
  public Token jj_nt;
  private int jj_ntk;
  private int jj_gen;
  final private int[] jj_la1 = new int[2];
  static private int[] jj_la1_0;
  static private int[] jj_la1_1;
  static {
      jj_la1_init_0();
      jj_la1_init_1();
   }
   private static void jj_la1_init_0() {
      jj_la1_0 = new int[] {0xfffffe00,0xfffffe00,};
   }
   private static void jj_la1_init_1() {
      jj_la1_1 = new int[] {0x7ffffff,0x7ffffff,};
   }

  /** Constructor with InputStream. */
  public Parser(java.io.InputStream stream) {
     this(stream, null);
  }
  /** Constructor with InputStream and supplied encoding */
  public Parser(java.io.InputStream stream, String encoding) {
    try { jj_input_stream = new SimpleCharStream(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source = new ParserTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 2; i++) jj_la1[i] = -1;
  }

  /** Reinitialise. */
  public void ReInit(java.io.InputStream stream) {
     ReInit(stream, null);
  }
  /** Reinitialise. */
  public void ReInit(java.io.InputStream stream, String encoding) {
    try { jj_input_stream.ReInit(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 2; i++) jj_la1[i] = -1;
  }

  /** Constructor. */
  public Parser(java.io.Reader stream) {
    jj_input_stream = new SimpleCharStream(stream, 1, 1);
    token_source = new ParserTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 2; i++) jj_la1[i] = -1;
  }

  /** Reinitialise. */
  public void ReInit(java.io.Reader stream) {
    jj_input_stream.ReInit(stream, 1, 1);
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 2; i++) jj_la1[i] = -1;
  }

  /** Constructor with generated Token Manager. */
  public Parser(ParserTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 2; i++) jj_la1[i] = -1;
  }

  /** Reinitialise. */
  public void ReInit(ParserTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 2; i++) jj_la1[i] = -1;
  }

  private Token jj_consume_token(int kind) throws ParseException {
    Token oldToken;
    if ((oldToken = token).next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    if (token.kind == kind) {
      jj_gen++;
      return token;
    }
    token = oldToken;
    jj_kind = kind;
    throw generateParseException();
  }


/** Get the next Token. */
  final public Token getNextToken() {
    if (token.next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    jj_gen++;
    return token;
  }

/** Get the specific Token. */
  final public Token getToken(int index) {
    Token t = token;
    for (int i = 0; i < index; i++) {
      if (t.next != null) t = t.next;
      else t = t.next = token_source.getNextToken();
    }
    return t;
  }

  private int jj_ntk() {
    if ((jj_nt=token.next) == null)
      return (jj_ntk = (token.next=token_source.getNextToken()).kind);
    else
      return (jj_ntk = jj_nt.kind);
  }

  private java.util.List<int[]> jj_expentries = new java.util.ArrayList<int[]>();
  private int[] jj_expentry;
  private int jj_kind = -1;

  /** Generate ParseException. */
  public ParseException generateParseException() {
    jj_expentries.clear();
    boolean[] la1tokens = new boolean[60];
    if (jj_kind >= 0) {
      la1tokens[jj_kind] = true;
      jj_kind = -1;
    }
    for (int i = 0; i < 2; i++) {
      if (jj_la1[i] == jj_gen) {
        for (int j = 0; j < 32; j++) {
          if ((jj_la1_0[i] & (1<<j)) != 0) {
            la1tokens[j] = true;
          }
          if ((jj_la1_1[i] & (1<<j)) != 0) {
            la1tokens[32+j] = true;
          }
        }
      }
    }
    for (int i = 0; i < 60; i++) {
      if (la1tokens[i]) {
        jj_expentry = new int[1];
        jj_expentry[0] = i;
        jj_expentries.add(jj_expentry);
      }
    }
    int[][] exptokseq = new int[jj_expentries.size()][];
    for (int i = 0; i < jj_expentries.size(); i++) {
      exptokseq[i] = jj_expentries.get(i);
    }
    return new ParseException(token, exptokseq, tokenImage);
  }

  /** Enable tracing. */
  final public void enable_tracing() {
  }

  /** Disable tracing. */
  final public void disable_tracing() {
  }

}
